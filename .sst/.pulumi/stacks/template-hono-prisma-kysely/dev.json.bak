{
    "version": 3,
    "checkpoint": {
        "stack": "organization/template-hono-prisma-kysely/dev",
        "latest": {
            "manifest": {
                "time": "2024-10-17T03:11:44.263995+08:00",
                "magic": "3b1911ae6e2d8d1f468975cdca7c3c6a48585f5e805330548231ecc6cfbc84ff",
                "version": "v3.136.1"
            },
            "secrets_providers": {
                "type": "passphrase",
                "state": {
                    "salt": "v1:L5f2Z9MJZns=:v1:2E3vdVwanlEdCrHd:8zouiYhyf357kCLTCC6Y+XxCLXOqTA=="
                }
            },
            "resources": [
                {
                    "urn": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:pulumi:Stack::template-hono-prisma-kysely-dev",
                    "custom": false,
                    "type": "pulumi:pulumi:Stack",
                    "created": "2024-10-16T18:43:58.413926Z",
                    "modified": "2024-10-16T18:43:58.413926Z",
                    "sourcePosition": "project:///platform/node_modules/@pulumi/runtime/stack.ts#38,23"
                },
                {
                    "urn": "urn:pulumi:dev::template-hono-prisma-kysely::sst:cloudflare:Worker::Home",
                    "custom": false,
                    "type": "sst:cloudflare:Worker",
                    "parent": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:pulumi:Stack::template-hono-prisma-kysely-dev",
                    "created": "2024-10-16T18:43:59.282943Z",
                    "modified": "2024-10-16T18:43:59.282943Z",
                    "sourcePosition": "project:///../file:/Users/bossrod/Desktop/Projects/Personal/template-hono-prisma-kysely/.sst/platform/src/components/cloudflare/worker.ts#238,5"
                },
                {
                    "urn": "urn:pulumi:dev::template-hono-prisma-kysely::sst:sst:LinkRef::HomeLinkRef",
                    "custom": false,
                    "type": "sst:sst:LinkRef",
                    "parent": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:pulumi:Stack::template-hono-prisma-kysely-dev",
                    "created": "2024-10-16T18:43:59.28091Z",
                    "modified": "2024-10-16T18:43:59.28091Z",
                    "sourcePosition": "project:///../file:/Users/bossrod/Desktop/Projects/Personal/template-hono-prisma-kysely/.sst/platform/src/components/link.ts#25,7"
                },
                {
                    "urn": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:providers:cloudflare::default_5_40_2",
                    "custom": true,
                    "id": "8f4058f2-b442-4bbf-936e-d17d24681ac0",
                    "type": "pulumi:providers:cloudflare",
                    "inputs": {
                        "__internal": {},
                        "apiClientLogging": "false",
                        "maxBackoff": "30",
                        "minBackoff": "1",
                        "retries": "3",
                        "rps": "4",
                        "version": "5.40.2"
                    },
                    "outputs": {
                        "apiClientLogging": "false",
                        "maxBackoff": "30",
                        "minBackoff": "1",
                        "retries": "3",
                        "rps": "4",
                        "version": "5.40.2"
                    },
                    "created": "2024-10-16T18:44:00.437721Z",
                    "modified": "2024-10-16T18:44:00.437721Z"
                },
                {
                    "urn": "urn:pulumi:dev::template-hono-prisma-kysely::sst:cloudflare:Bucket::ProjectEsports",
                    "custom": false,
                    "type": "sst:cloudflare:Bucket",
                    "parent": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:pulumi:Stack::template-hono-prisma-kysely-dev",
                    "created": "2024-10-16T18:43:59.282257Z",
                    "modified": "2024-10-16T18:43:59.282257Z",
                    "sourcePosition": "project:///../file:/Users/bossrod/Desktop/Projects/Personal/template-hono-prisma-kysely/.sst/platform/src/components/cloudflare/bucket.ts#61,5"
                },
                {
                    "urn": "urn:pulumi:dev::template-hono-prisma-kysely::sst:sst:LinkRef::ProjectEsportsLinkRef",
                    "custom": false,
                    "type": "sst:sst:LinkRef",
                    "outputs": {
                        "include": [
                            {
                                "binding": "r2BucketBindings",
                                "properties": {
                                    "bucketName": "template-hono-prisma-kysely-dev-projectesportsbucket"
                                },
                                "type": "cloudflare.binding"
                            }
                        ],
                        "properties": {
                            "type": "sst.cloudflare.Bucket"
                        },
                        "target": "ProjectEsports"
                    },
                    "parent": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:pulumi:Stack::template-hono-prisma-kysely-dev",
                    "created": "2024-10-16T18:43:59.281579Z",
                    "modified": "2024-10-16T18:43:59.281579Z",
                    "sourcePosition": "project:///../file:/Users/bossrod/Desktop/Projects/Personal/template-hono-prisma-kysely/.sst/platform/src/components/link.ts#25,7"
                },
                {
                    "urn": "urn:pulumi:dev::template-hono-prisma-kysely::sst:cloudflare:Bucket$cloudflare:index/r2Bucket:R2Bucket::ProjectEsportsBucket",
                    "custom": true,
                    "id": "template-hono-prisma-kysely-dev-projectesportsbucket",
                    "type": "cloudflare:index/r2Bucket:R2Bucket",
                    "inputs": {
                        "accountId": "9e6dc599200ae2a55acdbc0f9a761f83",
                        "name": "template-hono-prisma-kysely-dev-projectesportsbucket"
                    },
                    "outputs": {
                        "accountId": "9e6dc599200ae2a55acdbc0f9a761f83",
                        "id": "template-hono-prisma-kysely-dev-projectesportsbucket",
                        "location": "APAC",
                        "name": "template-hono-prisma-kysely-dev-projectesportsbucket"
                    },
                    "parent": "urn:pulumi:dev::template-hono-prisma-kysely::sst:cloudflare:Bucket::ProjectEsports",
                    "provider": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:providers:cloudflare::default_5_40_2::8f4058f2-b442-4bbf-936e-d17d24681ac0",
                    "propertyDependencies": {
                        "accountId": [],
                        "name": []
                    },
                    "created": "2024-10-16T18:44:03.409697Z",
                    "modified": "2024-10-16T18:44:03.409697Z",
                    "sourcePosition": "project:///../file:/Users/bossrod/Desktop/Projects/Personal/template-hono-prisma-kysely/.sst/platform/src/components/cloudflare/bucket.ts#70,14"
                }
            ],
            "pending_operations": [
                {
                    "resource": {
                        "urn": "urn:pulumi:dev::template-hono-prisma-kysely::sst:cloudflare:Worker$cloudflare:index/workerScript:WorkerScript::HomeScript",
                        "custom": true,
                        "type": "cloudflare:index/workerScript:WorkerScript",
                        "inputs": {
                            "__defaults": [],
                            "accountId": "9e6dc599200ae2a55acdbc0f9a761f83",
                            "compatibilityDate": "2024-09-23",
                            "compatibilityFlags": [
                                "nodejs_compat"
                            ],
                            "content": "var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/utils/html.js\nvar HtmlEscapedCallbackPhase = {\n  Stringify: 1,\n  BeforeStream: 2,\n  Stream: 3\n};\nvar raw = /* @__PURE__ */ __name((value, callbacks) => {\n  const escapedString = new String(value);\n  escapedString.isEscaped = true;\n  escapedString.callbacks = callbacks;\n  return escapedString;\n}, \"raw\");\nvar resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context, buffer) => {\n  const callbacks = str.callbacks;\n  if (!callbacks?.length) {\n    return Promise.resolve(str);\n  }\n  if (buffer) {\n    buffer[0] += str;\n  } else {\n    buffer = [str];\n  }\n  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(\n    (res) => Promise.all(\n      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))\n    ).then(() => buffer[0])\n  );\n  if (preserveCallbacks) {\n    return raw(await resStr, callbacks);\n  } else {\n    return resStr;\n  }\n}, \"resolveCallback\");\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/context.js\nvar TEXT_PLAIN = \"text/plain; charset=UTF-8\";\nvar setHeaders = /* @__PURE__ */ __name((headers, map = {}) => {\n  Object.entries(map).forEach(([key, value]) => headers.set(key, value));\n  return headers;\n}, \"setHeaders\");\nvar Context = class {\n  static {\n    __name(this, \"Context\");\n  }\n  req;\n  env = {};\n  _var;\n  finalized = false;\n  error = void 0;\n  #status = 200;\n  #executionCtx;\n  #headers = void 0;\n  #preparedHeaders = void 0;\n  #res;\n  #isFresh = true;\n  layout = void 0;\n  renderer = /* @__PURE__ */ __name((content) => this.html(content), \"renderer\");\n  notFoundHandler = /* @__PURE__ */ __name(() => new Response(), \"notFoundHandler\");\n  constructor(req, options) {\n    this.req = req;\n    if (options) {\n      this.#executionCtx = options.executionCtx;\n      this.env = options.env;\n      if (options.notFoundHandler) {\n        this.notFoundHandler = options.notFoundHandler;\n      }\n    }\n  }\n  get event() {\n    if (this.#executionCtx && \"respondWith\" in this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no FetchEvent\");\n    }\n  }\n  get executionCtx() {\n    if (this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no ExecutionContext\");\n    }\n  }\n  get res() {\n    this.#isFresh = false;\n    return this.#res ||= new Response(\"404 Not Found\", { status: 404 });\n  }\n  set res(_res) {\n    this.#isFresh = false;\n    if (this.#res && _res) {\n      this.#res.headers.delete(\"content-type\");\n      for (const [k, v] of this.#res.headers.entries()) {\n        if (k === \"set-cookie\") {\n          const cookies = this.#res.headers.getSetCookie();\n          _res.headers.delete(\"set-cookie\");\n          for (const cookie of cookies) {\n            _res.headers.append(\"set-cookie\", cookie);\n          }\n        } else {\n          _res.headers.set(k, v);\n        }\n      }\n    }\n    this.#res = _res;\n    this.finalized = true;\n  }\n  render = /* @__PURE__ */ __name((...args) => this.renderer(...args), \"render\");\n  setLayout = /* @__PURE__ */ __name((layout) => this.layout = layout, \"setLayout\");\n  getLayout = /* @__PURE__ */ __name(() => this.layout, \"getLayout\");\n  setRenderer = /* @__PURE__ */ __name((renderer) => {\n    this.renderer = renderer;\n  }, \"setRenderer\");\n  header = /* @__PURE__ */ __name((name, value, options) => {\n    if (value === void 0) {\n      if (this.#headers) {\n        this.#headers.delete(name);\n      } else if (this.#preparedHeaders) {\n        delete this.#preparedHeaders[name.toLocaleLowerCase()];\n      }\n      if (this.finalized) {\n        this.res.headers.delete(name);\n      }\n      return;\n    }\n    if (options?.append) {\n      if (!this.#headers) {\n        this.#isFresh = false;\n        this.#headers = new Headers(this.#preparedHeaders);\n        this.#preparedHeaders = {};\n      }\n      this.#headers.append(name, value);\n    } else {\n      if (this.#headers) {\n        this.#headers.set(name, value);\n      } else {\n        this.#preparedHeaders ??= {};\n        this.#preparedHeaders[name.toLowerCase()] = value;\n      }\n    }\n    if (this.finalized) {\n      if (options?.append) {\n        this.res.headers.append(name, value);\n      } else {\n        this.res.headers.set(name, value);\n      }\n    }\n  }, \"header\");\n  status = /* @__PURE__ */ __name((status) => {\n    this.#isFresh = false;\n    this.#status = status;\n  }, \"status\");\n  set = /* @__PURE__ */ __name((key, value) => {\n    this._var ??= {};\n    this._var[key] = value;\n  }, \"set\");\n  get = /* @__PURE__ */ __name((key) => {\n    return this._var ? this._var[key] : void 0;\n  }, \"get\");\n  get var() {\n    return { ...this._var };\n  }\n  newResponse = /* @__PURE__ */ __name((data, arg, headers) => {\n    if (this.#isFresh && !headers && !arg && this.#status === 200) {\n      return new Response(data, {\n        headers: this.#preparedHeaders\n      });\n    }\n    if (arg && typeof arg !== \"number\") {\n      const header = new Headers(arg.headers);\n      if (this.#headers) {\n        this.#headers.forEach((v, k) => {\n          if (k === \"set-cookie\") {\n            header.append(k, v);\n          } else {\n            header.set(k, v);\n          }\n        });\n      }\n      const headers2 = setHeaders(header, this.#preparedHeaders);\n      return new Response(data, {\n        headers: headers2,\n        status: arg.status ?? this.#status\n      });\n    }\n    const status = typeof arg === \"number\" ? arg : this.#status;\n    this.#preparedHeaders ??= {};\n    this.#headers ??= new Headers();\n    setHeaders(this.#headers, this.#preparedHeaders);\n    if (this.#res) {\n      this.#res.headers.forEach((v, k) => {\n        if (k === \"set-cookie\") {\n          this.#headers?.append(k, v);\n        } else {\n          this.#headers?.set(k, v);\n        }\n      });\n      setHeaders(this.#headers, this.#preparedHeaders);\n    }\n    headers ??= {};\n    for (const [k, v] of Object.entries(headers)) {\n      if (typeof v === \"string\") {\n        this.#headers.set(k, v);\n      } else {\n        this.#headers.delete(k);\n        for (const v2 of v) {\n          this.#headers.append(k, v2);\n        }\n      }\n    }\n    return new Response(data, {\n      status,\n      headers: this.#headers\n    });\n  }, \"newResponse\");\n  body = /* @__PURE__ */ __name((data, arg, headers) => {\n    return typeof arg === \"number\" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);\n  }, \"body\");\n  text = /* @__PURE__ */ __name((text, arg, headers) => {\n    if (!this.#preparedHeaders) {\n      if (this.#isFresh && !headers && !arg) {\n        return new Response(text);\n      }\n      this.#preparedHeaders = {};\n    }\n    this.#preparedHeaders[\"content-type\"] = TEXT_PLAIN;\n    return typeof arg === \"number\" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);\n  }, \"text\");\n  json = /* @__PURE__ */ __name((object, arg, headers) => {\n    const body = JSON.stringify(object);\n    this.#preparedHeaders ??= {};\n    this.#preparedHeaders[\"content-type\"] = \"application/json; charset=UTF-8\";\n    return typeof arg === \"number\" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);\n  }, \"json\");\n  html = /* @__PURE__ */ __name((html, arg, headers) => {\n    this.#preparedHeaders ??= {};\n    this.#preparedHeaders[\"content-type\"] = \"text/html; charset=UTF-8\";\n    if (typeof html === \"object\") {\n      if (!(html instanceof Promise)) {\n        html = html.toString();\n      }\n      if (html instanceof Promise) {\n        return html.then((html2) => resolveCallback(html2, HtmlEscapedCallbackPhase.Stringify, false, {})).then((html2) => {\n          return typeof arg === \"number\" ? this.newResponse(html2, arg, headers) : this.newResponse(html2, arg);\n        });\n      }\n    }\n    return typeof arg === \"number\" ? this.newResponse(html, arg, headers) : this.newResponse(html, arg);\n  }, \"html\");\n  redirect = /* @__PURE__ */ __name((location, status) => {\n    this.#headers ??= new Headers();\n    this.#headers.set(\"Location\", location);\n    return this.newResponse(null, status ?? 302);\n  }, \"redirect\");\n  notFound = /* @__PURE__ */ __name(() => {\n    return this.notFoundHandler(this);\n  }, \"notFound\");\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/compose.js\nvar compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {\n  return (context, next) => {\n    let index = -1;\n    return dispatch(0);\n    async function dispatch(i) {\n      if (i <= index) {\n        throw new Error(\"next() called multiple times\");\n      }\n      index = i;\n      let res;\n      let isError = false;\n      let handler;\n      if (middleware[i]) {\n        handler = middleware[i][0][0];\n        if (context instanceof Context) {\n          context.req.routeIndex = i;\n        }\n      } else {\n        handler = i === middleware.length && next || void 0;\n      }\n      if (!handler) {\n        if (context instanceof Context && context.finalized === false && onNotFound) {\n          res = await onNotFound(context);\n        }\n      } else {\n        try {\n          res = await handler(context, () => {\n            return dispatch(i + 1);\n          });\n        } catch (err) {\n          if (err instanceof Error && context instanceof Context && onError) {\n            context.error = err;\n            res = await onError(err, context);\n            isError = true;\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (res && (context.finalized === false || isError)) {\n        context.res = res;\n      }\n      return context;\n    }\n    __name(dispatch, \"dispatch\");\n  };\n}, \"compose\");\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/utils/body.js\nvar parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {\n  const { all = false, dot = false } = options;\n  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;\n  const contentType = headers.get(\"Content-Type\");\n  if (contentType !== null && contentType.startsWith(\"multipart/form-data\") || contentType !== null && contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n    return parseFormData(request, { all, dot });\n  }\n  return {};\n}, \"parseBody\");\nasync function parseFormData(request, options) {\n  const formData = await request.formData();\n  if (formData) {\n    return convertFormDataToBodyData(formData, options);\n  }\n  return {};\n}\n__name(parseFormData, \"parseFormData\");\nfunction convertFormDataToBodyData(formData, options) {\n  const form = /* @__PURE__ */ Object.create(null);\n  formData.forEach((value, key) => {\n    const shouldParseAllValues = options.all || key.endsWith(\"[]\");\n    if (!shouldParseAllValues) {\n      form[key] = value;\n    } else {\n      handleParsingAllValues(form, key, value);\n    }\n  });\n  if (options.dot) {\n    Object.entries(form).forEach(([key, value]) => {\n      const shouldParseDotValues = key.includes(\".\");\n      if (shouldParseDotValues) {\n        handleParsingNestedValues(form, key, value);\n        delete form[key];\n      }\n    });\n  }\n  return form;\n}\n__name(convertFormDataToBodyData, \"convertFormDataToBodyData\");\nvar handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {\n  if (form[key] !== void 0) {\n    if (Array.isArray(form[key])) {\n      ;\n      form[key].push(value);\n    } else {\n      form[key] = [form[key], value];\n    }\n  } else {\n    form[key] = value;\n  }\n}, \"handleParsingAllValues\");\nvar handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {\n  let nestedForm = form;\n  const keys = key.split(\".\");\n  keys.forEach((key2, index) => {\n    if (index === keys.length - 1) {\n      nestedForm[key2] = value;\n    } else {\n      if (!nestedForm[key2] || typeof nestedForm[key2] !== \"object\" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {\n        nestedForm[key2] = /* @__PURE__ */ Object.create(null);\n      }\n      nestedForm = nestedForm[key2];\n    }\n  });\n}, \"handleParsingNestedValues\");\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/utils/url.js\nvar splitPath = /* @__PURE__ */ __name((path) => {\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  return paths;\n}, \"splitPath\");\nvar splitRoutingPath = /* @__PURE__ */ __name((routePath) => {\n  const { groups, path } = extractGroupsFromPath(routePath);\n  const paths = splitPath(path);\n  return replaceGroupMarks(paths, groups);\n}, \"splitRoutingPath\");\nvar extractGroupsFromPath = /* @__PURE__ */ __name((path) => {\n  const groups = [];\n  path = path.replace(/\\{[^}]+\\}/g, (match, index) => {\n    const mark = `@${index}`;\n    groups.push([mark, match]);\n    return mark;\n  });\n  return { groups, path };\n}, \"extractGroupsFromPath\");\nvar replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {\n  for (let i = groups.length - 1; i >= 0; i--) {\n    const [mark] = groups[i];\n    for (let j = paths.length - 1; j >= 0; j--) {\n      if (paths[j].includes(mark)) {\n        paths[j] = paths[j].replace(mark, groups[i][1]);\n        break;\n      }\n    }\n  }\n  return paths;\n}, \"replaceGroupMarks\");\nvar patternCache = {};\nvar getPattern = /* @__PURE__ */ __name((label) => {\n  if (label === \"*\") {\n    return \"*\";\n  }\n  const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (match) {\n    if (!patternCache[label]) {\n      if (match[2]) {\n        patternCache[label] = [label, match[1], new RegExp(\"^\" + match[2] + \"$\")];\n      } else {\n        patternCache[label] = [label, match[1], true];\n      }\n    }\n    return patternCache[label];\n  }\n  return null;\n}, \"getPattern\");\nvar tryDecodeURI = /* @__PURE__ */ __name((str) => {\n  try {\n    return decodeURI(str);\n  } catch {\n    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {\n      try {\n        return decodeURI(match);\n      } catch {\n        return match;\n      }\n    });\n  }\n}, \"tryDecodeURI\");\nvar getPath = /* @__PURE__ */ __name((request) => {\n  const url = request.url;\n  const start = url.indexOf(\"/\", 8);\n  let i = start;\n  for (; i < url.length; i++) {\n    const charCode = url.charCodeAt(i);\n    if (charCode === 37) {\n      const queryIndex = url.indexOf(\"?\", i);\n      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);\n      return tryDecodeURI(path.includes(\"%25\") ? path.replace(/%25/g, \"%2525\") : path);\n    } else if (charCode === 63) {\n      break;\n    }\n  }\n  return url.slice(start, i);\n}, \"getPath\");\nvar getPathNoStrict = /* @__PURE__ */ __name((request) => {\n  const result = getPath(request);\n  return result.length > 1 && result[result.length - 1] === \"/\" ? result.slice(0, -1) : result;\n}, \"getPathNoStrict\");\nvar mergePath = /* @__PURE__ */ __name((...paths) => {\n  let p = \"\";\n  let endsWithSlash = false;\n  for (let path of paths) {\n    if (p[p.length - 1] === \"/\") {\n      p = p.slice(0, -1);\n      endsWithSlash = true;\n    }\n    if (path[0] !== \"/\") {\n      path = `/${path}`;\n    }\n    if (path === \"/\" && endsWithSlash) {\n      p = `${p}/`;\n    } else if (path !== \"/\") {\n      p = `${p}${path}`;\n    }\n    if (path === \"/\" && p === \"\") {\n      p = \"/\";\n    }\n  }\n  return p;\n}, \"mergePath\");\nvar checkOptionalParameter = /* @__PURE__ */ __name((path) => {\n  if (!path.match(/\\:.+\\?$/)) {\n    return null;\n  }\n  const segments = path.split(\"/\");\n  const results = [];\n  let basePath = \"\";\n  segments.forEach((segment) => {\n    if (segment !== \"\" && !/\\:/.test(segment)) {\n      basePath += \"/\" + segment;\n    } else if (/\\:/.test(segment)) {\n      if (/\\?/.test(segment)) {\n        if (results.length === 0 && basePath === \"\") {\n          results.push(\"/\");\n        } else {\n          results.push(basePath);\n        }\n        const optionalSegment = segment.replace(\"?\", \"\");\n        basePath += \"/\" + optionalSegment;\n        results.push(basePath);\n      } else {\n        basePath += \"/\" + segment;\n      }\n    }\n  });\n  return results.filter((v, i, a) => a.indexOf(v) === i);\n}, \"checkOptionalParameter\");\nvar _decodeURI = /* @__PURE__ */ __name((value) => {\n  if (!/[%+]/.test(value)) {\n    return value;\n  }\n  if (value.indexOf(\"+\") !== -1) {\n    value = value.replace(/\\+/g, \" \");\n  }\n  return /%/.test(value) ? decodeURIComponent_(value) : value;\n}, \"_decodeURI\");\nvar _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {\n  let encoded;\n  if (!multiple && key && !/[%+]/.test(key)) {\n    let keyIndex2 = url.indexOf(`?${key}`, 8);\n    if (keyIndex2 === -1) {\n      keyIndex2 = url.indexOf(`&${key}`, 8);\n    }\n    while (keyIndex2 !== -1) {\n      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);\n      if (trailingKeyCode === 61) {\n        const valueIndex = keyIndex2 + key.length + 2;\n        const endIndex = url.indexOf(\"&\", valueIndex);\n        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));\n      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {\n        return \"\";\n      }\n      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n    }\n    encoded = /[%+]/.test(url);\n    if (!encoded) {\n      return void 0;\n    }\n  }\n  const results = {};\n  encoded ??= /[%+]/.test(url);\n  let keyIndex = url.indexOf(\"?\", 8);\n  while (keyIndex !== -1) {\n    const nextKeyIndex = url.indexOf(\"&\", keyIndex + 1);\n    let valueIndex = url.indexOf(\"=\", keyIndex);\n    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {\n      valueIndex = -1;\n    }\n    let name = url.slice(\n      keyIndex + 1,\n      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex\n    );\n    if (encoded) {\n      name = _decodeURI(name);\n    }\n    keyIndex = nextKeyIndex;\n    if (name === \"\") {\n      continue;\n    }\n    let value;\n    if (valueIndex === -1) {\n      value = \"\";\n    } else {\n      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);\n      if (encoded) {\n        value = _decodeURI(value);\n      }\n    }\n    if (multiple) {\n      if (!(results[name] && Array.isArray(results[name]))) {\n        results[name] = [];\n      }\n      ;\n      results[name].push(value);\n    } else {\n      results[name] ??= value;\n    }\n  }\n  return key ? results[key] : results;\n}, \"_getQueryParam\");\nvar getQueryParam = _getQueryParam;\nvar getQueryParams = /* @__PURE__ */ __name((url, key) => {\n  return _getQueryParam(url, key, true);\n}, \"getQueryParams\");\nvar decodeURIComponent_ = decodeURIComponent;\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/request.js\nvar HonoRequest = class {\n  static {\n    __name(this, \"HonoRequest\");\n  }\n  raw;\n  #validatedData;\n  #matchResult;\n  routeIndex = 0;\n  path;\n  bodyCache = {};\n  constructor(request, path = \"/\", matchResult = [[]]) {\n    this.raw = request;\n    this.path = path;\n    this.#matchResult = matchResult;\n    this.#validatedData = {};\n  }\n  param(key) {\n    return key ? this.getDecodedParam(key) : this.getAllDecodedParams();\n  }\n  getDecodedParam(key) {\n    const paramKey = this.#matchResult[0][this.routeIndex][1][key];\n    const param = this.getParamValue(paramKey);\n    return param ? /\\%/.test(param) ? decodeURIComponent_(param) : param : void 0;\n  }\n  getAllDecodedParams() {\n    const decoded = {};\n    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n    for (const key of keys) {\n      const value = this.getParamValue(this.#matchResult[0][this.routeIndex][1][key]);\n      if (value && typeof value === \"string\") {\n        decoded[key] = /\\%/.test(value) ? decodeURIComponent_(value) : value;\n      }\n    }\n    return decoded;\n  }\n  getParamValue(paramKey) {\n    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;\n  }\n  query(key) {\n    return getQueryParam(this.url, key);\n  }\n  queries(key) {\n    return getQueryParams(this.url, key);\n  }\n  header(name) {\n    if (name) {\n      return this.raw.headers.get(name.toLowerCase()) ?? void 0;\n    }\n    const headerData = {};\n    this.raw.headers.forEach((value, key) => {\n      headerData[key] = value;\n    });\n    return headerData;\n  }\n  async parseBody(options) {\n    return this.bodyCache.parsedBody ??= await parseBody(this, options);\n  }\n  cachedBody = /* @__PURE__ */ __name((key) => {\n    const { bodyCache, raw: raw3 } = this;\n    const cachedBody = bodyCache[key];\n    if (cachedBody) {\n      return cachedBody;\n    }\n    const anyCachedKey = Object.keys(bodyCache)[0];\n    if (anyCachedKey) {\n      return bodyCache[anyCachedKey].then((body) => {\n        if (anyCachedKey === \"json\") {\n          body = JSON.stringify(body);\n        }\n        return new Response(body)[key]();\n      });\n    }\n    return bodyCache[key] = raw3[key]();\n  }, \"cachedBody\");\n  json() {\n    return this.cachedBody(\"json\");\n  }\n  text() {\n    return this.cachedBody(\"text\");\n  }\n  arrayBuffer() {\n    return this.cachedBody(\"arrayBuffer\");\n  }\n  blob() {\n    return this.cachedBody(\"blob\");\n  }\n  formData() {\n    return this.cachedBody(\"formData\");\n  }\n  addValidatedData(target, data) {\n    this.#validatedData[target] = data;\n  }\n  valid(target) {\n    return this.#validatedData[target];\n  }\n  get url() {\n    return this.raw.url;\n  }\n  get method() {\n    return this.raw.method;\n  }\n  get matchedRoutes() {\n    return this.#matchResult[0].map(([[, route]]) => route);\n  }\n  get routePath() {\n    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/router.js\nvar METHOD_NAME_ALL = \"ALL\";\nvar METHOD_NAME_ALL_LOWERCASE = \"all\";\nvar METHODS = [\"get\", \"post\", \"put\", \"delete\", \"options\", \"patch\"];\nvar MESSAGE_MATCHER_IS_ALREADY_BUILT = \"Can not add a route since the matcher is already built.\";\nvar UnsupportedPathError = class extends Error {\n  static {\n    __name(this, \"UnsupportedPathError\");\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/hono-base.js\nvar COMPOSED_HANDLER = Symbol(\"composedHandler\");\nvar notFoundHandler = /* @__PURE__ */ __name((c) => {\n  return c.text(\"404 Not Found\", 404);\n}, \"notFoundHandler\");\nvar errorHandler = /* @__PURE__ */ __name((err, c) => {\n  if (\"getResponse\" in err) {\n    return err.getResponse();\n  }\n  console.error(err);\n  return c.text(\"Internal Server Error\", 500);\n}, \"errorHandler\");\nvar Hono = class {\n  static {\n    __name(this, \"Hono\");\n  }\n  get;\n  post;\n  put;\n  delete;\n  options;\n  patch;\n  all;\n  on;\n  use;\n  router;\n  getPath;\n  _basePath = \"/\";\n  #path = \"/\";\n  routes = [];\n  constructor(options = {}) {\n    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];\n    allMethods.forEach((method) => {\n      this[method] = (args1, ...args) => {\n        if (typeof args1 === \"string\") {\n          this.#path = args1;\n        } else {\n          this.addRoute(method, this.#path, args1);\n        }\n        args.forEach((handler) => {\n          if (typeof handler !== \"string\") {\n            this.addRoute(method, this.#path, handler);\n          }\n        });\n        return this;\n      };\n    });\n    this.on = (method, path, ...handlers) => {\n      for (const p of [path].flat()) {\n        this.#path = p;\n        for (const m of [method].flat()) {\n          handlers.map((handler) => {\n            this.addRoute(m.toUpperCase(), this.#path, handler);\n          });\n        }\n      }\n      return this;\n    };\n    this.use = (arg1, ...handlers) => {\n      if (typeof arg1 === \"string\") {\n        this.#path = arg1;\n      } else {\n        this.#path = \"*\";\n        handlers.unshift(arg1);\n      }\n      handlers.forEach((handler) => {\n        this.addRoute(METHOD_NAME_ALL, this.#path, handler);\n      });\n      return this;\n    };\n    const strict = options.strict ?? true;\n    delete options.strict;\n    Object.assign(this, options);\n    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;\n  }\n  clone() {\n    const clone = new Hono({\n      router: this.router,\n      getPath: this.getPath\n    });\n    clone.routes = this.routes;\n    return clone;\n  }\n  notFoundHandler = notFoundHandler;\n  errorHandler = errorHandler;\n  route(path, app2) {\n    const subApp = this.basePath(path);\n    app2.routes.map((r) => {\n      let handler;\n      if (app2.errorHandler === errorHandler) {\n        handler = r.handler;\n      } else {\n        handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app2.errorHandler)(c, () => r.handler(c, next))).res, \"handler\");\n        handler[COMPOSED_HANDLER] = r.handler;\n      }\n      subApp.addRoute(r.method, r.path, handler);\n    });\n    return this;\n  }\n  basePath(path) {\n    const subApp = this.clone();\n    subApp._basePath = mergePath(this._basePath, path);\n    return subApp;\n  }\n  onError = /* @__PURE__ */ __name((handler) => {\n    this.errorHandler = handler;\n    return this;\n  }, \"onError\");\n  notFound = /* @__PURE__ */ __name((handler) => {\n    this.notFoundHandler = handler;\n    return this;\n  }, \"notFound\");\n  mount(path, applicationHandler, options) {\n    let replaceRequest;\n    let optionHandler;\n    if (options) {\n      if (typeof options === \"function\") {\n        optionHandler = options;\n      } else {\n        optionHandler = options.optionHandler;\n        replaceRequest = options.replaceRequest;\n      }\n    }\n    const getOptions = optionHandler ? (c) => {\n      const options2 = optionHandler(c);\n      return Array.isArray(options2) ? options2 : [options2];\n    } : (c) => {\n      let executionContext = void 0;\n      try {\n        executionContext = c.executionCtx;\n      } catch {\n      }\n      return [c.env, executionContext];\n    };\n    replaceRequest ||= (() => {\n      const mergedPath = mergePath(this._basePath, path);\n      const pathPrefixLength = mergedPath === \"/\" ? 0 : mergedPath.length;\n      return (request) => {\n        const url = new URL(request.url);\n        url.pathname = url.pathname.slice(pathPrefixLength) || \"/\";\n        return new Request(url, request);\n      };\n    })();\n    const handler = /* @__PURE__ */ __name(async (c, next) => {\n      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));\n      if (res) {\n        return res;\n      }\n      await next();\n    }, \"handler\");\n    this.addRoute(METHOD_NAME_ALL, mergePath(path, \"*\"), handler);\n    return this;\n  }\n  addRoute(method, path, handler) {\n    method = method.toUpperCase();\n    path = mergePath(this._basePath, path);\n    const r = { path, method, handler };\n    this.router.add(method, path, [handler, r]);\n    this.routes.push(r);\n  }\n  matchRoute(method, path) {\n    return this.router.match(method, path);\n  }\n  handleError(err, c) {\n    if (err instanceof Error) {\n      return this.errorHandler(err, c);\n    }\n    throw err;\n  }\n  dispatch(request, executionCtx, env2, method) {\n    if (method === \"HEAD\") {\n      return (async () => new Response(null, await this.dispatch(request, executionCtx, env2, \"GET\")))();\n    }\n    const path = this.getPath(request, { env: env2 });\n    const matchResult = this.matchRoute(method, path);\n    const c = new Context(new HonoRequest(request, path, matchResult), {\n      env: env2,\n      executionCtx,\n      notFoundHandler: this.notFoundHandler\n    });\n    if (matchResult[0].length === 1) {\n      let res;\n      try {\n        res = matchResult[0][0][0][0](c, async () => {\n          c.res = await this.notFoundHandler(c);\n        });\n      } catch (err) {\n        return this.handleError(err, c);\n      }\n      return res instanceof Promise ? res.then(\n        (resolved) => resolved || (c.finalized ? c.res : this.notFoundHandler(c))\n      ).catch((err) => this.handleError(err, c)) : res ?? this.notFoundHandler(c);\n    }\n    const composed = compose(matchResult[0], this.errorHandler, this.notFoundHandler);\n    return (async () => {\n      try {\n        const context = await composed(c);\n        if (!context.finalized) {\n          throw new Error(\n            \"Context is not finalized. Did you forget to return a Response object or `await next()`?\"\n          );\n        }\n        return context.res;\n      } catch (err) {\n        return this.handleError(err, c);\n      }\n    })();\n  }\n  fetch = /* @__PURE__ */ __name((request, ...rest) => {\n    return this.dispatch(request, rest[1], rest[0], request.method);\n  }, \"fetch\");\n  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {\n    if (input instanceof Request) {\n      if (requestInit !== void 0) {\n        input = new Request(input, requestInit);\n      }\n      return this.fetch(input, Env, executionCtx);\n    }\n    input = input.toString();\n    const path = /^https?:\\/\\//.test(input) ? input : `http://localhost${mergePath(\"/\", input)}`;\n    const req = new Request(path, requestInit);\n    return this.fetch(req, Env, executionCtx);\n  }, \"request\");\n  fire = /* @__PURE__ */ __name(() => {\n    addEventListener(\"fetch\", (event) => {\n      event.respondWith(this.dispatch(event.request, event, void 0, event.request.method));\n    });\n  }, \"fire\");\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/router/reg-exp-router/node.js\nvar LABEL_REG_EXP_STR = \"[^/]+\";\nvar ONLY_WILDCARD_REG_EXP_STR = \".*\";\nvar TAIL_WILDCARD_REG_EXP_STR = \"(?:|/.*)\";\nvar PATH_ERROR = Symbol();\nvar regExpMetaChars = new Set(\".\\\\+*[^]$()\");\nfunction compareKey(a, b) {\n  if (a.length === 1) {\n    return b.length === 1 ? a < b ? -1 : 1 : -1;\n  }\n  if (b.length === 1) {\n    return 1;\n  }\n  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {\n    return 1;\n  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {\n    return -1;\n  }\n  if (a === LABEL_REG_EXP_STR) {\n    return 1;\n  } else if (b === LABEL_REG_EXP_STR) {\n    return -1;\n  }\n  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;\n}\n__name(compareKey, \"compareKey\");\nvar Node = class {\n  static {\n    __name(this, \"Node\");\n  }\n  index;\n  varIndex;\n  children = /* @__PURE__ */ Object.create(null);\n  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {\n    if (tokens.length === 0) {\n      if (this.index !== void 0) {\n        throw PATH_ERROR;\n      }\n      if (pathErrorCheckOnly) {\n        return;\n      }\n      this.index = index;\n      return;\n    }\n    const [token, ...restTokens] = tokens;\n    const pattern = token === \"*\" ? restTokens.length === 0 ? [\"\", \"\", ONLY_WILDCARD_REG_EXP_STR] : [\"\", \"\", LABEL_REG_EXP_STR] : token === \"/*\" ? [\"\", \"\", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n    let node;\n    if (pattern) {\n      const name = pattern[1];\n      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;\n      if (name && pattern[2]) {\n        regexpStr = regexpStr.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, \"(?:\");\n        if (/\\((?!\\?:)/.test(regexpStr)) {\n          throw PATH_ERROR;\n        }\n      }\n      node = this.children[regexpStr];\n      if (!node) {\n        if (Object.keys(this.children).some(\n          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.children[regexpStr] = new Node();\n        if (name !== \"\") {\n          node.varIndex = context.varIndex++;\n        }\n      }\n      if (!pathErrorCheckOnly && name !== \"\") {\n        paramMap.push([name, node.varIndex]);\n      }\n    } else {\n      node = this.children[token];\n      if (!node) {\n        if (Object.keys(this.children).some(\n          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.children[token] = new Node();\n      }\n    }\n    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);\n  }\n  buildRegExpStr() {\n    const childKeys = Object.keys(this.children).sort(compareKey);\n    const strList = childKeys.map((k) => {\n      const c = this.children[k];\n      return (typeof c.varIndex === \"number\" ? `(${k})@${c.varIndex}` : regExpMetaChars.has(k) ? `\\\\${k}` : k) + c.buildRegExpStr();\n    });\n    if (typeof this.index === \"number\") {\n      strList.unshift(`#${this.index}`);\n    }\n    if (strList.length === 0) {\n      return \"\";\n    }\n    if (strList.length === 1) {\n      return strList[0];\n    }\n    return \"(?:\" + strList.join(\"|\") + \")\";\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/router/reg-exp-router/trie.js\nvar Trie = class {\n  static {\n    __name(this, \"Trie\");\n  }\n  context = { varIndex: 0 };\n  root = new Node();\n  insert(path, index, pathErrorCheckOnly) {\n    const paramAssoc = [];\n    const groups = [];\n    for (let i = 0; ; ) {\n      let replaced = false;\n      path = path.replace(/\\{[^}]+\\}/g, (m) => {\n        const mark = `@\\\\${i}`;\n        groups[i] = [mark, m];\n        i++;\n        replaced = true;\n        return mark;\n      });\n      if (!replaced) {\n        break;\n      }\n    }\n    const tokens = path.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n    for (let i = groups.length - 1; i >= 0; i--) {\n      const [mark] = groups[i];\n      for (let j = tokens.length - 1; j >= 0; j--) {\n        if (tokens[j].indexOf(mark) !== -1) {\n          tokens[j] = tokens[j].replace(mark, groups[i][1]);\n          break;\n        }\n      }\n    }\n    this.root.insert(tokens, index, paramAssoc, this.context, pathErrorCheckOnly);\n    return paramAssoc;\n  }\n  buildRegExp() {\n    let regexp = this.root.buildRegExpStr();\n    if (regexp === \"\") {\n      return [/^$/, [], []];\n    }\n    let captureIndex = 0;\n    const indexReplacementMap = [];\n    const paramReplacementMap = [];\n    regexp = regexp.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (_, handlerIndex, paramIndex) => {\n      if (typeof handlerIndex !== \"undefined\") {\n        indexReplacementMap[++captureIndex] = Number(handlerIndex);\n        return \"$()\";\n      }\n      if (typeof paramIndex !== \"undefined\") {\n        paramReplacementMap[Number(paramIndex)] = ++captureIndex;\n        return \"\";\n      }\n      return \"\";\n    });\n    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/router/reg-exp-router/router.js\nvar emptyParam = [];\nvar nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];\nvar wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\nfunction buildWildcardRegExp(path) {\n  return wildcardRegExpCache[path] ??= new RegExp(\n    path === \"*\" ? \"\" : `^${path.replace(\n      /\\/\\*$|([.\\\\+*[^\\]$()])/g,\n      (_, metaChar) => metaChar ? `\\\\${metaChar}` : \"(?:|/.*)\"\n    )}$`\n  );\n}\n__name(buildWildcardRegExp, \"buildWildcardRegExp\");\nfunction clearWildcardRegExpCache() {\n  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\n}\n__name(clearWildcardRegExpCache, \"clearWildcardRegExpCache\");\nfunction buildMatcherFromPreprocessedRoutes(routes) {\n  const trie = new Trie();\n  const handlerData = [];\n  if (routes.length === 0) {\n    return nullMatcher;\n  }\n  const routesWithStaticPathFlag = routes.map(\n    (route) => [!/\\*|\\/:/.test(route[0]), ...route]\n  ).sort(\n    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length\n  );\n  const staticMap = /* @__PURE__ */ Object.create(null);\n  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {\n    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];\n    if (pathErrorCheckOnly) {\n      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];\n    } else {\n      j++;\n    }\n    let paramAssoc;\n    try {\n      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);\n    } catch (e) {\n      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;\n    }\n    if (pathErrorCheckOnly) {\n      continue;\n    }\n    handlerData[j] = handlers.map(([h, paramCount]) => {\n      const paramIndexMap = /* @__PURE__ */ Object.create(null);\n      paramCount -= 1;\n      for (; paramCount >= 0; paramCount--) {\n        const [key, value] = paramAssoc[paramCount];\n        paramIndexMap[key] = value;\n      }\n      return [h, paramIndexMap];\n    });\n  }\n  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();\n  for (let i = 0, len = handlerData.length; i < len; i++) {\n    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {\n      const map = handlerData[i][j]?.[1];\n      if (!map) {\n        continue;\n      }\n      const keys = Object.keys(map);\n      for (let k = 0, len3 = keys.length; k < len3; k++) {\n        map[keys[k]] = paramReplacementMap[map[keys[k]]];\n      }\n    }\n  }\n  const handlerMap = [];\n  for (const i in indexReplacementMap) {\n    handlerMap[i] = handlerData[indexReplacementMap[i]];\n  }\n  return [regexp, handlerMap, staticMap];\n}\n__name(buildMatcherFromPreprocessedRoutes, \"buildMatcherFromPreprocessedRoutes\");\nfunction findMiddleware(middleware, path) {\n  if (!middleware) {\n    return void 0;\n  }\n  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {\n    if (buildWildcardRegExp(k).test(path)) {\n      return [...middleware[k]];\n    }\n  }\n  return void 0;\n}\n__name(findMiddleware, \"findMiddleware\");\nvar RegExpRouter = class {\n  static {\n    __name(this, \"RegExpRouter\");\n  }\n  name = \"RegExpRouter\";\n  middleware;\n  routes;\n  constructor() {\n    this.middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n    this.routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n  }\n  add(method, path, handler) {\n    const { middleware, routes } = this;\n    if (!middleware || !routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    if (!middleware[method]) {\n      ;\n      [middleware, routes].forEach((handlerMap) => {\n        handlerMap[method] = /* @__PURE__ */ Object.create(null);\n        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {\n          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];\n        });\n      });\n    }\n    if (path === \"/*\") {\n      path = \"*\";\n    }\n    const paramCount = (path.match(/\\/:/g) || []).length;\n    if (/\\*$/.test(path)) {\n      const re = buildWildcardRegExp(path);\n      if (method === METHOD_NAME_ALL) {\n        Object.keys(middleware).forEach((m) => {\n          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n        });\n      } else {\n        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n      }\n      Object.keys(middleware).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(middleware[m]).forEach((p) => {\n            re.test(p) && middleware[m][p].push([handler, paramCount]);\n          });\n        }\n      });\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(routes[m]).forEach(\n            (p) => re.test(p) && routes[m][p].push([handler, paramCount])\n          );\n        }\n      });\n      return;\n    }\n    const paths = checkOptionalParameter(path) || [path];\n    for (let i = 0, len = paths.length; i < len; i++) {\n      const path2 = paths[i];\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          routes[m][path2] ||= [\n            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []\n          ];\n          routes[m][path2].push([handler, paramCount - len + i + 1]);\n        }\n      });\n    }\n  }\n  match(method, path) {\n    clearWildcardRegExpCache();\n    const matchers = this.buildAllMatchers();\n    this.match = (method2, path2) => {\n      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];\n      const staticMatch = matcher[2][path2];\n      if (staticMatch) {\n        return staticMatch;\n      }\n      const match = path2.match(matcher[0]);\n      if (!match) {\n        return [[], emptyParam];\n      }\n      const index = match.indexOf(\"\", 1);\n      return [matcher[1][index], match];\n    };\n    return this.match(method, path);\n  }\n  buildAllMatchers() {\n    const matchers = /* @__PURE__ */ Object.create(null);\n    [...Object.keys(this.routes), ...Object.keys(this.middleware)].forEach((method) => {\n      matchers[method] ||= this.buildMatcher(method);\n    });\n    this.middleware = this.routes = void 0;\n    return matchers;\n  }\n  buildMatcher(method) {\n    const routes = [];\n    let hasOwnRoute = method === METHOD_NAME_ALL;\n    [this.middleware, this.routes].forEach((r) => {\n      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];\n      if (ownRoute.length !== 0) {\n        hasOwnRoute ||= true;\n        routes.push(...ownRoute);\n      } else if (method !== METHOD_NAME_ALL) {\n        routes.push(\n          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])\n        );\n      }\n    });\n    if (!hasOwnRoute) {\n      return null;\n    } else {\n      return buildMatcherFromPreprocessedRoutes(routes);\n    }\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/router/smart-router/router.js\nvar SmartRouter = class {\n  static {\n    __name(this, \"SmartRouter\");\n  }\n  name = \"SmartRouter\";\n  routers = [];\n  routes = [];\n  constructor(init) {\n    Object.assign(this, init);\n  }\n  add(method, path, handler) {\n    if (!this.routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    this.routes.push([method, path, handler]);\n  }\n  match(method, path) {\n    if (!this.routes) {\n      throw new Error(\"Fatal error\");\n    }\n    const { routers, routes } = this;\n    const len = routers.length;\n    let i = 0;\n    let res;\n    for (; i < len; i++) {\n      const router = routers[i];\n      try {\n        routes.forEach((args) => {\n          router.add(...args);\n        });\n        res = router.match(method, path);\n      } catch (e) {\n        if (e instanceof UnsupportedPathError) {\n          continue;\n        }\n        throw e;\n      }\n      this.match = router.match.bind(router);\n      this.routers = [router];\n      this.routes = void 0;\n      break;\n    }\n    if (i === len) {\n      throw new Error(\"Fatal error\");\n    }\n    this.name = `SmartRouter + ${this.activeRouter.name}`;\n    return res;\n  }\n  get activeRouter() {\n    if (this.routes || this.routers.length !== 1) {\n      throw new Error(\"No active router has been determined yet.\");\n    }\n    return this.routers[0];\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/router/trie-router/node.js\nvar Node2 = class {\n  static {\n    __name(this, \"Node\");\n  }\n  methods;\n  children;\n  patterns;\n  order = 0;\n  name;\n  params = /* @__PURE__ */ Object.create(null);\n  constructor(method, handler, children) {\n    this.children = children || /* @__PURE__ */ Object.create(null);\n    this.methods = [];\n    this.name = \"\";\n    if (method && handler) {\n      const m = /* @__PURE__ */ Object.create(null);\n      m[method] = { handler, possibleKeys: [], score: 0, name: this.name };\n      this.methods = [m];\n    }\n    this.patterns = [];\n  }\n  insert(method, path, handler) {\n    this.name = `${method} ${path}`;\n    this.order = ++this.order;\n    let curNode = this;\n    const parts = splitRoutingPath(path);\n    const possibleKeys = [];\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p = parts[i];\n      if (Object.keys(curNode.children).includes(p)) {\n        curNode = curNode.children[p];\n        const pattern2 = getPattern(p);\n        if (pattern2) {\n          possibleKeys.push(pattern2[1]);\n        }\n        continue;\n      }\n      curNode.children[p] = new Node2();\n      const pattern = getPattern(p);\n      if (pattern) {\n        curNode.patterns.push(pattern);\n        possibleKeys.push(pattern[1]);\n      }\n      curNode = curNode.children[p];\n    }\n    if (!curNode.methods.length) {\n      curNode.methods = [];\n    }\n    const m = /* @__PURE__ */ Object.create(null);\n    const handlerSet = {\n      handler,\n      possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),\n      name: this.name,\n      score: this.order\n    };\n    m[method] = handlerSet;\n    curNode.methods.push(m);\n    return curNode;\n  }\n  gHSets(node, method, nodeParams, params) {\n    const handlerSets = [];\n    for (let i = 0, len = node.methods.length; i < len; i++) {\n      const m = node.methods[i];\n      const handlerSet = m[method] || m[METHOD_NAME_ALL];\n      const processedSet = /* @__PURE__ */ Object.create(null);\n      if (handlerSet !== void 0) {\n        handlerSet.params = /* @__PURE__ */ Object.create(null);\n        handlerSet.possibleKeys.forEach((key) => {\n          const processed = processedSet[handlerSet.name];\n          handlerSet.params[key] = params[key] && !processed ? params[key] : nodeParams[key] ?? params[key];\n          processedSet[handlerSet.name] = true;\n        });\n        handlerSets.push(handlerSet);\n      }\n    }\n    return handlerSets;\n  }\n  search(method, path) {\n    const handlerSets = [];\n    this.params = /* @__PURE__ */ Object.create(null);\n    const curNode = this;\n    let curNodes = [curNode];\n    const parts = splitPath(path);\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part = parts[i];\n      const isLast = i === len - 1;\n      const tempNodes = [];\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j];\n        const nextNode = node.children[part];\n        if (nextNode) {\n          nextNode.params = node.params;\n          if (isLast === true) {\n            if (nextNode.children[\"*\"]) {\n              handlerSets.push(\n                ...this.gHSets(nextNode.children[\"*\"], method, node.params, /* @__PURE__ */ Object.create(null))\n              );\n            }\n            handlerSets.push(...this.gHSets(nextNode, method, node.params, /* @__PURE__ */ Object.create(null)));\n          } else {\n            tempNodes.push(nextNode);\n          }\n        }\n        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {\n          const pattern = node.patterns[k];\n          const params = { ...node.params };\n          if (pattern === \"*\") {\n            const astNode = node.children[\"*\"];\n            if (astNode) {\n              handlerSets.push(...this.gHSets(astNode, method, node.params, /* @__PURE__ */ Object.create(null)));\n              tempNodes.push(astNode);\n            }\n            continue;\n          }\n          if (part === \"\") {\n            continue;\n          }\n          const [key, name, matcher] = pattern;\n          const child = node.children[key];\n          const restPathString = parts.slice(i).join(\"/\");\n          if (matcher instanceof RegExp && matcher.test(restPathString)) {\n            params[name] = restPathString;\n            handlerSets.push(...this.gHSets(child, method, node.params, params));\n            continue;\n          }\n          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {\n            if (typeof key === \"string\") {\n              params[name] = part;\n              if (isLast === true) {\n                handlerSets.push(...this.gHSets(child, method, params, node.params));\n                if (child.children[\"*\"]) {\n                  handlerSets.push(...this.gHSets(child.children[\"*\"], method, params, node.params));\n                }\n              } else {\n                child.params = params;\n                tempNodes.push(child);\n              }\n            }\n          }\n        }\n      }\n      curNodes = tempNodes;\n    }\n    const results = handlerSets.sort((a, b) => {\n      return a.score - b.score;\n    });\n    return [results.map(({ handler, params }) => [handler, params])];\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/router/trie-router/router.js\nvar TrieRouter = class {\n  static {\n    __name(this, \"TrieRouter\");\n  }\n  name = \"TrieRouter\";\n  node;\n  constructor() {\n    this.node = new Node2();\n  }\n  add(method, path, handler) {\n    const results = checkOptionalParameter(path);\n    if (results) {\n      for (const p of results) {\n        this.node.insert(method, p, handler);\n      }\n      return;\n    }\n    this.node.insert(method, path, handler);\n  }\n  match(method, path) {\n    return this.node.search(method, path);\n  }\n};\n\n// node_modules/.pnpm/hono@4.4.7/node_modules/hono/dist/hono.js\nvar Hono2 = class extends Hono {\n  static {\n    __name(this, \"Hono\");\n  }\n  constructor(options = {}) {\n    super(options);\n    this.router = options.router ?? new SmartRouter({\n      routers: [new RegExpRouter(), new TrieRouter()]\n    });\n  }\n};\n\n// cloudflare/workers/index.ts\nvar app = new Hono2().get(\"/\", async (c) => {\n  return c.text(\"Hello World\");\n});\nvar workers_default = app;\n\n// node_modules/.pnpm/sst@3.2.31_hono@4.4.7/node_modules/sst/dist/resource.js\nimport { env } from \"node:process\";\n\n// .sst/platform/node_modules/unenv/runtime/_internal/utils.mjs\nfunction createNotImplementedError(name) {\n  throw new Error(`[unenv] ${name} is not implemented yet!`);\n}\n__name(createNotImplementedError, \"createNotImplementedError\");\nfunction notImplemented(name) {\n  const fn = /* @__PURE__ */ __name(() => {\n    throw createNotImplementedError(name);\n  }, \"fn\");\n  return Object.assign(fn, { __unenv__: true });\n}\n__name(notImplemented, \"notImplemented\");\n\n// .sst/platform/node_modules/unenv/runtime/node/fs/promises/_promises.mjs\nvar access = notImplemented(\"fs.access\");\nvar copyFile = notImplemented(\"fs.copyFile\");\nvar cp = notImplemented(\"fs.cp\");\nvar open = notImplemented(\"fs.open\");\nvar opendir = notImplemented(\"fs.opendir\");\nvar rename = notImplemented(\"fs.rename\");\nvar truncate = notImplemented(\"fs.truncate\");\nvar rm = notImplemented(\"fs.rm\");\nvar rmdir = notImplemented(\"fs.rmdir\");\nvar mkdir = notImplemented(\"fs.mkdir\");\nvar readdir = notImplemented(\"fs.readdir\");\nvar readlink = notImplemented(\"fs.readlink\");\nvar symlink = notImplemented(\"fs.symlink\");\nvar lstat = notImplemented(\"fs.lstat\");\nvar stat = notImplemented(\"fs.stat\");\nvar link = notImplemented(\"fs.link\");\nvar unlink = notImplemented(\"fs.unlink\");\nvar chmod = notImplemented(\"fs.chmod\");\nvar lchmod = notImplemented(\"fs.lchmod\");\nvar lchown = notImplemented(\"fs.lchown\");\nvar chown = notImplemented(\"fs.chown\");\nvar utimes = notImplemented(\"fs.utimes\");\nvar lutimes = notImplemented(\"fs.lutimes\");\nvar realpath = notImplemented(\"fs.realpath\");\nvar mkdtemp = notImplemented(\"fs.mkdtemp\");\nvar writeFile = notImplemented(\"fs.writeFile\");\nvar appendFile = notImplemented(\"fs.appendFile\");\nvar readFile = notImplemented(\"fs.readFile\");\nvar watch = notImplemented(\"fs.watch\");\nvar statfs = notImplemented(\"fs.statfs\");\n\n// .sst/platform/node_modules/unenv/runtime/node/fs/_fs.mjs\nfunction notImplementedAsync(name) {\n  const fn = notImplemented(name);\n  fn.__promisify__ = () => notImplemented(name + \".__promisify__\");\n  fn.native = fn;\n  return fn;\n}\n__name(notImplementedAsync, \"notImplementedAsync\");\nfunction callbackify(fn) {\n  const fnc = /* @__PURE__ */ __name(function(...args) {\n    const cb = args.pop();\n    fn().catch((error) => cb(error)).then((val) => cb(void 0, val));\n  }, \"fnc\");\n  fnc.__promisify__ = fn;\n  fnc.native = fnc;\n  return fnc;\n}\n__name(callbackify, \"callbackify\");\nvar access2 = callbackify(access);\nvar appendFile2 = callbackify(appendFile);\nvar chown2 = callbackify(chown);\nvar chmod2 = callbackify(chmod);\nvar copyFile2 = callbackify(copyFile);\nvar cp2 = callbackify(cp);\nvar lchown2 = callbackify(lchown);\nvar lchmod2 = callbackify(lchmod);\nvar link2 = callbackify(link);\nvar lstat2 = callbackify(lstat);\nvar lutimes2 = callbackify(lutimes);\nvar mkdir2 = callbackify(mkdir);\nvar mkdtemp2 = callbackify(mkdtemp);\nvar realpath2 = callbackify(realpath);\nvar open2 = callbackify(open);\nvar opendir2 = callbackify(opendir);\nvar readdir2 = callbackify(readdir);\nvar readFile2 = callbackify(readFile);\nvar readlink2 = callbackify(readlink);\nvar rename2 = callbackify(rename);\nvar rm2 = callbackify(rm);\nvar rmdir2 = callbackify(rmdir);\nvar stat2 = callbackify(stat);\nvar symlink2 = callbackify(symlink);\nvar truncate2 = callbackify(truncate);\nvar unlink2 = callbackify(unlink);\nvar utimes2 = callbackify(utimes);\nvar writeFile2 = callbackify(writeFile);\nvar statfs2 = callbackify(statfs);\nvar close = notImplementedAsync(\"fs.close\");\nvar createReadStream = notImplementedAsync(\n  \"fs.createReadStream\"\n);\nvar createWriteStream = notImplementedAsync(\"fs.createWriteStream\");\nvar exists = notImplementedAsync(\"fs.exists\");\nvar fchown = notImplementedAsync(\"fs.fchown\");\nvar fchmod = notImplementedAsync(\"fs.fchmod\");\nvar fdatasync = notImplementedAsync(\"fs.fdatasync\");\nvar fstat = notImplementedAsync(\"fs.fstat\");\nvar fsync = notImplementedAsync(\"fs.fsync\");\nvar ftruncate = notImplementedAsync(\"fs.ftruncate\");\nvar futimes = notImplementedAsync(\"fs.futimes\");\nvar lstatSync = notImplementedAsync(\"fs.lstatSync\");\nvar read = notImplementedAsync(\"fs.read\");\nvar readv = notImplementedAsync(\"fs.readv\");\nvar realpathSync = notImplementedAsync(\"fs.realpathSync\");\nvar statSync = notImplementedAsync(\"fs.statSync\");\nvar unwatchFile = notImplementedAsync(\"fs.unwatchFile\");\nvar watch2 = notImplementedAsync(\"fs.watch\");\nvar watchFile = notImplementedAsync(\"fs.watchFile\");\nvar write = notImplementedAsync(\"fs.write\");\nvar writev = notImplementedAsync(\"fs.writev\");\nvar _toUnixTimestamp = notImplementedAsync(\"fs._toUnixTimestamp\");\nvar openAsBlob = notImplementedAsync(\"fs.openAsBlob\");\nvar appendFileSync = notImplemented(\"fs.appendFileSync\");\nvar accessSync = notImplemented(\"fs.accessSync\");\nvar chownSync = notImplemented(\"fs.chownSync\");\nvar chmodSync = notImplemented(\"fs.chmodSync\");\nvar closeSync = notImplemented(\"fs.closeSync\");\nvar copyFileSync = notImplemented(\"fs.copyFileSync\");\nvar cpSync = notImplemented(\"fs.cpSync\");\nvar fchownSync = notImplemented(\"fs.fchownSync\");\nvar fchmodSync = notImplemented(\"fs.fchmodSync\");\nvar fdatasyncSync = notImplemented(\"fs.fdatasyncSync\");\nvar fstatSync = notImplemented(\"fs.fstatSync\");\nvar fsyncSync = notImplemented(\"fs.fsyncSync\");\nvar ftruncateSync = notImplemented(\"fs.ftruncateSync\");\nvar futimesSync = notImplemented(\"fs.futimesSync\");\nvar lchownSync = notImplemented(\"fs.lchownSync\");\nvar lchmodSync = notImplemented(\"fs.lchmodSync\");\nvar linkSync = notImplemented(\"fs.linkSync\");\nvar lutimesSync = notImplemented(\"fs.lutimesSync\");\nvar mkdirSync = notImplemented(\"fs.mkdirSync\");\nvar mkdtempSync = notImplemented(\"fs.mkdtempSync\");\nvar openSync = notImplemented(\"fs.openSync\");\nvar opendirSync = notImplemented(\"fs.opendirSync\");\nvar readdirSync = notImplemented(\"fs.readdirSync\");\nvar readSync = notImplemented(\"fs.readSync\");\nvar readvSync = notImplemented(\"fs.readvSync\");\nvar readFileSync = notImplemented(\"fs.readFileSync\");\nvar readlinkSync = notImplemented(\"fs.readlinkSync\");\nvar renameSync = notImplemented(\"fs.renameSync\");\nvar rmSync = notImplemented(\"fs.rmSync\");\nvar rmdirSync = notImplemented(\"fs.rmdirSync\");\nvar symlinkSync = notImplemented(\"fs.symlinkSync\");\nvar truncateSync = notImplemented(\"fs.truncateSync\");\nvar unlinkSync = notImplemented(\"fs.unlinkSync\");\nvar utimesSync = notImplemented(\"fs.utimesSync\");\nvar writeFileSync = notImplemented(\"fs.writeFileSync\");\nvar writeSync = notImplemented(\"fs.writeSync\");\nvar writevSync = notImplemented(\"fs.writevSync\");\nvar statfsSync = notImplemented(\"fs.statfsSync\");\n\n// node_modules/.pnpm/sst@3.2.31_hono@4.4.7/node_modules/sst/dist/resource.js\nimport crypto from \"node:crypto\";\nvar raw2 = {\n  // @ts-expect-error,\n  ...globalThis.$SST_LINKS\n};\nvar environment = {\n  ...env,\n  ...globalThis.process?.env\n};\nfor (const [key, value] of Object.entries(environment)) {\n  if (key.startsWith(\"SST_RESOURCE_\") && value) {\n    raw2[key.slice(\"SST_RESOURCE_\".length)] = JSON.parse(value);\n  }\n}\nif (env.SST_KEY_FILE && env.SST_KEY && !globalThis.SST_KEY_FILE_DATA) {\n  const key = Buffer.from(env.SST_KEY, \"base64\");\n  const encryptedData = readFileSync(env.SST_KEY_FILE);\n  const nonce = Buffer.alloc(12, 0);\n  const decipher = crypto.createDecipheriv(\"aes-256-gcm\", key, nonce);\n  const authTag = encryptedData.subarray(-16);\n  const actualCiphertext = encryptedData.subarray(0, -16);\n  decipher.setAuthTag(authTag);\n  let decrypted = decipher.update(actualCiphertext);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  const decryptedData = JSON.parse(decrypted.toString());\n  Object.assign(raw2, decryptedData);\n}\nif (globalThis.SST_KEY_FILE_DATA) {\n  Object.assign(raw2, globalThis.SST_KEY_FILE_DATA);\n}\nfunction fromCloudflareEnv(input) {\n  for (let [key, value] of Object.entries(input)) {\n    if (typeof value === \"string\") {\n      try {\n        value = JSON.parse(value);\n      } catch {\n      }\n    }\n    raw2[key] = value;\n    if (key.startsWith(\"SST_RESOURCE_\")) {\n      raw2[key.replace(\"SST_RESOURCE_\", \"\")] = value;\n    }\n  }\n}\n__name(fromCloudflareEnv, \"fromCloudflareEnv\");\nfunction wrapCloudflareHandler(handler) {\n  if (typeof handler === \"function\" && handler.hasOwnProperty(\"prototype\")) {\n    return class extends handler {\n      constructor(ctx, env2) {\n        fromCloudflareEnv(env2);\n        super(ctx, env2);\n      }\n    };\n  }\n  function wrap(fn) {\n    return function(req, env2, ...rest) {\n      fromCloudflareEnv(env2);\n      return fn(req, env2, ...rest);\n    };\n  }\n  __name(wrap, \"wrap\");\n  const result = {};\n  for (const [key, value] of Object.entries(handler)) {\n    result[key] = wrap(value);\n  }\n  return result;\n}\n__name(wrapCloudflareHandler, \"wrapCloudflareHandler\");\nvar Resource = new Proxy(raw2, {\n  get(_target, prop) {\n    if (prop in raw2) {\n      return raw2[prop];\n    }\n    if (!env.SST_RESOURCE_App) {\n      throw new Error(\"It does not look like SST links are active. If this is in local development and you are not starting this process through the multiplexer, wrap your command with `sst dev -- <command>`\");\n    }\n    let msg = `\"${prop}\" is not linked in your sst.config.ts`;\n    if (env.AWS_LAMBDA_FUNCTION_NAME) {\n      msg += ` to ${env.AWS_LAMBDA_FUNCTION_NAME}`;\n    }\n    throw new Error(msg);\n  }\n});\n\n// <stdin>\nvar stdin_default = wrapCloudflareHandler(workers_default);\nexport {\n  stdin_default as default\n};\n",
                            "module": true,
                            "name": "template-hono-prisma-kysely-dev-homescript",
                            "plainTextBindings": [
                                {
                                    "__defaults": [],
                                    "name": "SST_RESOURCE_App",
                                    "text": "{\"name\":\"template-hono-prisma-kysely\",\"stage\":\"dev\"}"
                                }
                            ],
                            "secretTextBindings": []
                        },
                        "parent": "urn:pulumi:dev::template-hono-prisma-kysely::sst:cloudflare:Worker::Home",
                        "provider": "urn:pulumi:dev::template-hono-prisma-kysely::pulumi:providers:cloudflare::default_5_40_2::8f4058f2-b442-4bbf-936e-d17d24681ac0",
                        "propertyDependencies": {
                            "accountId": [],
                            "compatibilityDate": [],
                            "compatibilityFlags": [],
                            "content": [],
                            "module": [],
                            "name": [],
                            "plainTextBindings": [],
                            "secretTextBindings": []
                        },
                        "sourcePosition": "project:///platform/node_modules/@pulumi/workerScript.ts#209,9"
                    },
                    "type": "creating"
                }
            ],
            "metadata": {}
        }
    }
}
